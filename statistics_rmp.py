# -*- coding: utf-8 -*-
"""Statistics RMP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FAmJX0ssmMFctaTcRBw8H6C5kBTTWlFv
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import ttest_ind

# ----- Data Paths -----
samples = {
    "WTAD1": "/content/drive/MyDrive/PatchClampData/Python2/WTAD1.asc",
    "WTAD2": "/content/drive/MyDrive/PatchClampData/Python2/WTAD2.asc",
    "WTAD3": "/content/drive/MyDrive/PatchClampData/Python2/WTAD3.asc",
    "WTAD4": "/content/drive/MyDrive/PatchClampData/Python2/WTAD4.asc",
    "WTAD5": "/content/drive/MyDrive/PatchClampData/Python2/WTAD5.asc",
    "WTAD6": "/content/drive/MyDrive/PatchClampData/Python2/WTAD6.asc",
    "WTAD7": "/content/drive/MyDrive/PatchClampData/Python2/WTAD7.asc",
    "AD1": "/content/drive/MyDrive/PatchClampData/Python2/AD1.asc",
    "AD2": "/content/drive/MyDrive/PatchClampData/Python2/AD2.asc",
    "AD4": "/content/drive/MyDrive/PatchClampData/Python2/AD4.asc",
    "AD5": "/content/drive/MyDrive/PatchClampData/Python2/AD5.asc",
    "AD6": "/content/drive/MyDrive/PatchClampData/Python2/AD6.asc",
    "AD7": "/content/drive/MyDrive/PatchClampData/Python2/AD6a.asc",
    "AD8": "/content/drive/MyDrive/PatchClampData/Python2/AD8.asc",
    "AD10": "/content/drive/MyDrive/PatchClampData/Python2/AD10.asc"
}

# ----- Parameters -----
baseline_window = 5  # Baseline window in seconds
rmp_values = {"WT Group": [], "Mutant Group": []}

# ----- Data Processing -----
for sample, file_path in samples.items():
    try:
        # Load the data
        data = pd.read_csv(file_path, sep=',', skiprows=6, header=None)
        if data.shape[1] == 4:
            data.columns = ["Index", "Time[s]", "V-mon[V]", "Stimulus"]
        else:
            data.columns = ["Index", "Time[s]", "V-mon[V]"]

        # Extract time and voltage
        time = data["Time[s]"].values
        voltage = data["V-mon[V]"].values * 1000  # Convert to mV

        # Filter data for baseline window
        baseline_voltage = voltage[time <= baseline_window]
        avg_rmp = np.mean(baseline_voltage)

        # Classify sample as WT Group or Mutant Group
        if "WTAD" in sample:
            rmp_values["WT Group"].append(avg_rmp)
        else:
            rmp_values["Mutant Group"].append(avg_rmp)

    except Exception as e:
        print(f"Error processing {sample}: {e}")

# ----- Statistical Analysis -----
t_stat, p_value = ttest_ind(rmp_values["WT Group"], rmp_values["Mutant Group"])

# Significance Level
if p_value < 0.001:
    significance = "***"
elif p_value < 0.01:
    significance = "**"
elif p_value < 0.05:
    significance = "*"
else:
    significance = "ns"  # No Significance

# ----- Visualization -----
plt.figure(figsize=(8, 6))
colors = ['green', 'purple']  # Fictional group colors
labels = ['WT Group', 'Mutant Group']
mean_rmp = [np.mean(rmp_values["WT Group"]), np.mean(rmp_values["Mutant Group"])]
sem_rmp = [np.std(rmp_values["WT Group"]) / np.sqrt(len(rmp_values["WT Group"])),
           np.std(rmp_values["Mutant Group"]) / np.sqrt(len(rmp_values["Mutant Group"]))]

# Bar plot with error bars and scatter points
for i, (rmp, color, label) in enumerate(zip([rmp_values["WT Group"], rmp_values["Mutant Group"]], colors, labels)):
    plt.bar(i, mean_rmp[i], color=color, width=0.6, alpha=0.6, edgecolor='black')
    plt.errorbar(i, mean_rmp[i], yerr=sem_rmp[i], fmt='k_', capsize=10)
    plt.scatter(np.full(len(rmp), i), rmp, color=color, edgecolor='black', s=100, zorder=3)
    plt.text(i, mean_rmp[i] - 1.5, f"n = {len(rmp)}", ha='center', fontsize=12)

# Invert Y-axis for RMP visualization
plt.gca().invert_yaxis()

# Labels and styling
plt.xticks([0, 1], labels)
plt.ylabel('Resting Membrane Potential (mV)')

# Remove spines
ax = plt.gca()
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)

# Add significance annotation
x1, x2 = 0, 1
y, h, col = min(mean_rmp) - 1, 1, 'black'
plt.plot([x1, x1, x2, x2], [y, y-h, y-h, y], lw=1.5, color=col)
plt.text((x1 + x2) * 0.5, y - h, significance, ha='center', va='bottom', color=col, fontsize=16)

plt.tight_layout()
plt.savefig('rmp_plot_generic.svg', format='svg', bbox_inches='tight')
plt.show()

# ----- Export Data for GraphPad Prism -----
rmp_data = pd.DataFrame({
    'Group': ['WT Group'] * len(rmp_values["WT Group"]) + ['Mutant Group'] * len(rmp_values["Mutant Group"]),
    'Resting Membrane Potential (mV)': rmp_values["WT Group"] + rmp_values["Mutant Group"]
})
rmp_data.to_csv('rmp_data_for_prism_generic.csv', index=False)

# ----- Print Summary -----
print("✅ RMP plot saved as 'rmp_plot_generic.svg'")
print("✅ RMP data exported as 'rmp_data_for_prism_generic.csv'")
print(f"WT Group RMP: {rmp_values['WT Group']}")
print(f"Mutant Group RMP: {rmp_values['Mutant Group']}")
print(f"p-value: {p_value:.4f} ({significance})")

# ----- Notes for GitHub -----
"""
- This script calculates and visualizes the resting membrane potential (RMP) for wild-type (WT) and mutant recordings.
- Group names in the graph are anonymized as "WT Group" and "Mutant Group" for privacy.
- The `file_path` values should point to your actual .asc files.
"""